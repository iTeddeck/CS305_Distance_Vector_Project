#BlueJ class context
comment0.params=portNum\ rTable\ serverSocket\ poison
comment0.target=ListenerThread(int,\ RoutingTable,\ java.net.DatagramSocket,\ boolean)
comment1.params=
comment1.target=void\ run()
comment2.params=messageArray\ stringIPFrom\ stringPortFrom
comment2.target=void\ parseMessage(java.lang.String[],\ java.lang.String,\ java.lang.String)
comment3.params=messageArray
comment3.target=java.util.ArrayList\ parseCollidedMessage(java.lang.String[])
comment4.params=messageArray\ collidedMessage
comment4.target=java.lang.String\ parseCollidedIndex(java.util.ArrayList,\ java.lang.String)
comment5.params=ipFrom\ portFrom\ newWeight
comment5.target=void\ changeNeighborTable(java.lang.String,\ java.lang.String,\ java.lang.String)
comment6.params=distanceVector\ ipFromString\ portFromString
comment6.target=void\ parseReceivedDV(java.lang.String[],\ java.lang.String,\ java.lang.String)
comment7.params=entryComponent\ indexOfSender
comment7.target=void\ addDVEntryToTable(java.lang.String[],\ int)
comment8.params=
comment8.target=boolean\ calculateDistanceVector()
comment8.text=public\ boolean\ calculateDistanceVector()\ {\n\ \ \ \ boolean\ didChange\ \=\ false;\n\ \ \ \ for(int\ i\ \=\ 0;\ i\ <\ rTable.outwardIP.get(0).size();i++)\ {\n\ \ \ \ System.out.println("here");\n\ \ \ \ IPPort\ destLoc\ \=\ rTable.outwardIP.get(0).get(i);\n\n\ \ \ \ int\ currentCost\ \=\ rTable.costToGet.get(0).get(i);\n\ \ \ \ IPPort\ currentNexHop\ \=\ rTable.whereToForward.get(i);\n\n\ \ \ \ int\ newCost\ \=\ 10000000;\n\ \ \ \ IPPort\ newNextHop\ \=\ null;\n\n\ \ \ \ for(int\ j\ \=\ 0;\ j\ <\ rTable.neighborAddresses.size();\ j++)\ {\n\ \ \ \ int\ costToNeighbor\ \=\ rTable.costToNeighbor.get(j);\n\n\ \ \ \ int\ indexOfDestLocInNeighbor\ \=\ -1;\n\ \ \ \ int\ costToDestThroughNeighbor\ \=\ -1;\n\ \ \ \ for(int\ k\ \=\ 0;\ k\ <\ rTable.outwardIP.get(j).size();\ k++)\ {\n\ \ \ \ if(rTable.outwardIP.get(j).get(k).getIP().equals(destLoc.getIP())\n\ \ \ \ &&\ rTable.outwardIP.get(j).get(k).getPort().equals(destLoc.getPort()))\ {\n\ \ \ \ indexOfDestLocInNeighbor\ \=\ k;\n\ \ \ \ break;\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ costToDestThroughNeighbor\ \=\ rTable.costToGet.get(j).get(indexOfDestLocInNeighbor)\ +\ costToNeighbor;\n\ \ \ \ if(costToDestThroughNeighbor\ <\ newCost)\ {\n\ \ \ \ newCost\ \=\ costToDestThroughNeighbor;\n\ \ \ \ newNextHop\ \=\ rTable.neighborAddresses.get(i);\n\ \ \ \ }\n\ \ \ \ }\n\n\ \ \ \ if(newCost\ <\ currentCost)\ {\n\ \ \ \ rTable.costToGet.get(0).set(i,\ newCost);\n\ \ \ \ rTable.outwardIP.get(0).set(i,\ newNextHop);\n\ \ \ \ didChange\ \=\ true;\n\ \ \ \ }\n\ \ \ \ }\n\n\ \ \ \ return\ didChange;\n}
comment9.params=
comment9.target=void\ sendDistanceVector()
numComments=10
